//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.  
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user’s design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : SPI Flash Controller
// File             : wb_intf.v
// Title            : Wishbone Interface of SPI Flash Controller
// Version          : 3.0
//                  : Initial Version (replaces deprecated SPI Flash ROM v3.1)
// Version          : 3.2
//                  : Support for 8-bit WISHBONE data bus. Updated memory map
//                  : for registers accessible through control port to allow
//                  : for 8- and 32-bit WISHBONE data bus to access them
//                  : uniformly.
// Version          : 3.6
//					: Fixed the issue of the Controller return Manufacturer ID
//					: for MICO8 and MICO32 
// =============================================================================
module wb_intf
  #(parameter S_WB_DAT_WIDTH    = 32,
    parameter S_WB_ADR_WIDTH    = 32,
    parameter C_PORT_ENABLE     = 1,
    parameter C_WB_DAT_WIDTH    = 32,
    parameter C_WB_ADR_WIDTH    = 11,
    parameter WB_DAT_WIDTH      = 32,
    parameter PAGE_PRG_BUF_ENA  = 1,
    parameter PAGE_READ_BUF_ENA = 1,
    parameter BUF_WIDTH         = 6,
    parameter PAGE_WIDTH        = 8,
    parameter SPI_READ          = 8'h03,
    parameter SPI_FAST_READ     = 8'h0b,
    parameter SPI_BYTE_PRG      = 8'h02,
    parameter SPI_PAGE_PRG      = 8'h02,
    parameter SPI_BLK1_ERS      = 8'h20,
    parameter SPI_BLK2_ERS      = 8'h52,
    parameter SPI_BLK3_ERS      = 8'hd8,
    parameter SPI_CHIP_ERS      = 8'h60,
    parameter SPI_WRT_ENB       = 8'h06,
    parameter SPI_WRT_DISB      = 8'h04,
    parameter SPI_READ_STAT     = 8'h05,
    parameter SPI_WRT_STAT      = 8'h01,
    parameter SPI_PWD_DOWN      = 8'hb9,
    parameter SPI_PWD_UP        = 8'hab,
    parameter SPI_DEV_ID        = 8'h9f
   )
   (
    // wishbone PORT A signals
    input [S_WB_ADR_WIDTH-1:0] S_ADR_I,
    input [S_WB_DAT_WIDTH-1:0] S_DAT_I,
    input S_WE_I,
    input S_STB_I,
    input S_CYC_I,
    input [S_WB_DAT_WIDTH/8-1:0] S_SEL_I,
    input [2:0] S_CTI_I,
    input [1:0] S_BTE_I,
    output reg [S_WB_DAT_WIDTH-1:0] S_DAT_O,
    output reg S_ACK_O,
    output S_ERR_O,
    output S_RTY_O,
    
    // wishbone PORT B signals
    input [C_WB_ADR_WIDTH-1:0] C_ADR_I,
    input [C_WB_DAT_WIDTH-1:0] C_DAT_I,
    input C_WE_I,
    input C_STB_I,
    input C_CYC_I,
    input [C_WB_DAT_WIDTH/8-1:0] C_SEL_I,
    input [2:0] C_CTI_I,
    input [1:0] C_BTE_I,
    output [C_WB_DAT_WIDTH-1:0] C_DAT_O,
    output C_ACK_O,
    output C_ERR_O,
    output C_RTY_O,
    
    // command from wishbone to SPI flash signals
    output reg [31:0] spi_cmd, // command and address send to spi flash
    output reg [31:0] spi_cmd_ext, // extended high 4 bytes of command address send to spi flash (only used for arbitrary command)
    output reg [3:0] cmd_bytes, // command and address byte numbers send to spi flash
    output reg [PAGE_WIDTH:0] byte_length, // data bytes after address command
    output reg page_cmd, // page program or page read command
    output reg wr_enb, // precede a write enable command
    output reg [WB_DAT_WIDTH-1:0] write_data, // data write to spi flash
    output [7:0] spi_wrt_enb, // spi write enable command byte
    output [7:0] spi_read_stat, // spi read status register command byte
    output fast_read, // read command is fast read
    output reg spi_wr, // asserted when spi write command
    output reg spi_req, // request a spi command, deasserted when detect a positive edge on spi_ack
    input spi_ack, // acknowledge a spi command, deasserted when the transaction is finished
    input [WB_DAT_WIDTH-1:0] read_data, // return data from spi flash
    
    output [BUF_WIDTH-1:0] wb2spi_wr_addr,
    output [C_WB_DAT_WIDTH-1:0] wb2spi_data,
    output wb2spi_we,
    
    input [C_WB_DAT_WIDTH-1:0] spi2wb_q,
    output [BUF_WIDTH-1:0] spi2wb_rd_addr,
        
    // system signals
    input CLK_I,
    input RST_I
    );
   
   reg [WB_DAT_WIDTH-1:0] read_data_arb;
   
   // SPI Operation Code Byte
   wire [7:0] 		  spi_read;      // 8'h03   Slow read command
   wire [7:0] 		  spi_fast_read; // 8'h0b   Fast read command
   wire [7:0] 		  spi_byte_prg;  // 8'h02   Byte program command
   wire [7:0] 		  spi_page_prg;  // 8'h02   Page program command
   wire [7:0] 		  spi_blk1_ers;  // 8'h20   Type1 block erase, 4K erase
   wire [7:0] 		  spi_blk2_ers;  // 8'h52   Type2 block erase, 32k erase
   wire [7:0] 		  spi_blk3_ers;  // 8'hD8   Type3 block erase, 64k erase
   wire [7:0] 		  spi_chip_ers;  // 8'h60   Chip erase command
   wire [7:0] 		  spi_wrt_disb;  // 8'h04   Write disable command
   wire [7:0] 		  spi_wrt_stat;  // 8'h10   Write status register
   wire [7:0] 		  spi_pwd_down;  // 8'hB9   Deep power down
   wire [7:0] 		  spi_pwd_up;    // 8'hAB   Resume from deep power down
   wire [7:0] 		  spi_dev_id;    // 8'h9F   Read manufacturer and device ID
   reg [7:0] 		  reg_spi_read, reg_spi_fast_read;
   reg [7:0] 		  reg_spi_byte_prg, reg_spi_page_prg, reg_spi_chip_ers;
   reg [7:0] 		  reg_spi_blk1_ers, reg_spi_blk2_ers, reg_spi_blk3_ers;
   reg [7:0] 		  reg_spi_wrt_disb, reg_spi_wrt_enb;
   reg [7:0] 		  reg_spi_wrt_stat, reg_spi_read_stat;
   reg [7:0] 		  reg_spi_dev_id, reg_spi_pwd_down, reg_spi_pwd_up;
   reg 			  reg_fast_read;
   
   // Control port signals
   wire [WB_DAT_WIDTH-1:0] ALIGN_ctrl_write_data;
   wire 		   ctrl_port_req;
   wire [23:0] 		   ctrl_port_cmd;
   wire [7:0] 		   ctrl_port_dat;
   reg [3:0] 		   ctrl_cmd_bytes;
   reg [PAGE_WIDTH:0] 	   ctrl_byte_length;
   reg 			   ctrl_page_cmd;
   reg 			   ctrl_wr_enb;
   reg [31:0] 		   ctrl_spi_cmd;
   reg 			   ctrl_spi_wr;
   reg [7:0] 		   ctrl_write_data;
      
   // Wishbone State Machine
   reg [1:0] 		  wb_state;
   reg 			  ctr_state;
   parameter WB_IDLE  = 2'b00;
   parameter WB_PORTA = 2'b01;
   parameter WB_PORTB = 2'b10;
   
   parameter CTR_IDLE = 1'b0;
   parameter CTR_CMD  = 1'b1;

   /*----------------------------------------------------------------------
    
    SPI Flash Data Port
    
    ----------------------------------------------------------------------*/
   assign S_ERR_O = 1'b0;
   assign S_RTY_O = 1'b0;
   
   generate
      if (S_WB_DAT_WIDTH == 8) begin

	 wire [WB_DAT_WIDTH-1:0] ALIGN_S_DAT_I;
	 if (WB_DAT_WIDTH == 8)
	   assign ALIGN_S_DAT_I = S_DAT_I;
	 else
	   assign ALIGN_S_DAT_I = {S_DAT_I, 24'b0};
	 
	 always @(posedge CLK_I or posedge RST_I)
	   if (RST_I) begin
	      
	      wb_state      <= WB_IDLE;
	      spi_cmd       <= 32'h00000000;
	      cmd_bytes     <= 0;
	      byte_length   <= 1;
	      page_cmd      <= 1'b0;
	      wr_enb        <= 1'b0;
	      write_data    <= 8'h00;
	      spi_wr        <= 1'b0;
	      spi_req       <= 1'b0;
	      S_ACK_O       <= 1'b0;
	      S_DAT_O       <= 8'h00;
	   end 
	   else begin
	      
	      case (wb_state)
		WB_IDLE:
		  if (spi_ack == 1'b0) begin
		     
		     if (S_STB_I && S_CYC_I && ~S_ACK_O) begin
			
			if (S_WE_I) begin
			   
			   spi_cmd[31:0]<= {spi_page_prg,S_ADR_I[23:0]};
			   spi_wr        <= 1'b1;
			   wr_enb        <= 1'b1;
			   S_ACK_O       <= 1'b1;
			end 
			else begin
			   
			   if (fast_read)
			     spi_cmd[31:0] <= {spi_fast_read,S_ADR_I[23:0]};
			   else
			     spi_cmd[31:0] <= {spi_read,S_ADR_I[23:0]};
			   spi_wr        <= 1'b0;
			   wr_enb        <= 1'b0;
			   S_ACK_O       <= 1'b0;
			end // else: !if (S_WE_I)
			
			byte_length   <= 1;
			write_data    <= ALIGN_S_DAT_I;
			cmd_bytes     <= 4;
			page_cmd      <= 1'b0;
			spi_req       <= 1'b1;
			wb_state      <= WB_PORTA;
		     end
		     else if (ctrl_port_req) begin
			
			S_ACK_O       <= 1'b0;
		       	
			cmd_bytes     <= ctrl_cmd_bytes;
			byte_length   <= ctrl_byte_length;
			page_cmd      <= ctrl_page_cmd;
			wr_enb        <= ctrl_wr_enb;
			write_data    <= ALIGN_ctrl_write_data;
			spi_cmd       <= ctrl_spi_cmd;
			spi_wr        <= ctrl_spi_wr;
			spi_req       <= 1'b1;
			wb_state      <= WB_PORTB;
		     end // if (ctrl_port_req)
		     else
		       S_ACK_O <= 1'b0;
		  end // if (!spi_ack)
	       	  else
		    S_ACK_O <= 1'b0;
		
		WB_PORTA:
		  if (spi_ack) begin
		    
		     spi_req  <= 1'b0;
		     wb_state <= WB_IDLE;
		     if (~spi_wr) begin
			
		       S_ACK_O <= 1'b1;
		       S_DAT_O <= read_data;
		    end 
		     else
		      S_ACK_O <= 1'b0;
		  end 
		  else
		    S_ACK_O <= 1'b0;
		
		WB_PORTB:
		  if (spi_ack) begin
		     
		     spi_req <= 1'b0;
		     wb_state <= WB_IDLE;
		  end
		
		default: begin
		   
		   spi_req <= 1'b0;
		   wb_state <= WB_IDLE;
		end
	      endcase // case (wb_state)
	   end // else: !if(RST_I)
      end // if (S_WB_DAT_WIDTH == 8)
      else begin
	 
	 always @(posedge CLK_I or posedge RST_I)
	   if (RST_I) begin
	      
	      wb_state      <= WB_IDLE;
	      spi_cmd       <= 32'h00000000;
	      cmd_bytes     <= 0;
	      byte_length   <= 4;
	      page_cmd      <= 1'b0;
	      wr_enb        <= 1'b0;
	      write_data    <= 32'h00000000;
	      spi_wr        <= 1'b0;
	      spi_req       <= 1'b0;
	      S_ACK_O       <= 1'b0;
	      S_DAT_O       <= 32'h00000000;
	   end 
	   else begin
	      
	      case (wb_state)
		WB_IDLE:
		  if (!spi_ack) begin
		     
		     if (S_STB_I && S_CYC_I && ~S_ACK_O) begin
			
			if (S_WE_I) begin
			   
			   spi_cmd[31:2]<= {spi_page_prg,S_ADR_I[23:2]};
			   spi_wr        <= 1'b1;
			   wr_enb        <= 1'b1;
			   S_ACK_O       <= 1'b1;
			end 
			else begin
			   
			   if (fast_read)
			     spi_cmd[31:2] <= {spi_fast_read,S_ADR_I[23:2]};
			   else
			     spi_cmd[31:2] <= {spi_read,S_ADR_I[23:2]};
			   spi_wr        <= 1'b0;
			   wr_enb        <= 1'b0;
			   S_ACK_O       <= 1'b0;
			end // else: !if (S_WE_I)
			
			case (S_SEL_I)
			  4'b0001:begin
			     
			     spi_cmd[1:0]  <= 2'b11;
			     byte_length   <= 1;
			     write_data    <= {S_DAT_I[7:0],24'h000000};
			  end
			  4'b0010:begin
			     
			     spi_cmd[1:0]  <= 2'b10;
			     byte_length   <= 1;
			     write_data    <= {S_DAT_I[15:8],24'h000000};
			  end
			  4'b0100:begin
			     
			     spi_cmd[1:0]  <= 2'b01;
			     byte_length   <= 1;
			     write_data    <= {S_DAT_I[23:16],24'h000000};
			  end
			  4'b1000:begin
			     
			     spi_cmd[1:0]  <= 2'b00;
			     byte_length   <= 1;
			     write_data    <= {S_DAT_I[31:24],24'h000000};
			  end
			  4'b0011:begin
			     
			     spi_cmd[1:0]  <= 2'b10;
			     byte_length   <= 2;
			     write_data    <= {S_DAT_I[15:0],16'h0000};
			  end
			  4'b0110:begin
			     
			     spi_cmd[1:0]  <= 2'b01;
			     byte_length   <= 2;
			     write_data    <= {S_DAT_I[23:8],16'h0000};
			  end
			  4'b1100:begin
			     
			     spi_cmd[1:0]  <= 2'b00;
			     byte_length   <= 2;
			     write_data    <= {S_DAT_I[31:16],24'h0000};
			  end
			  4'b0111:begin
			     
			     spi_cmd[1:0]  <= 2'b01;
			     byte_length   <= 3;
			     write_data    <= {S_DAT_I[23:0],8'h00};
			  end
			  4'b1110:begin
			     
			     spi_cmd[1:0]  <= 2'b00;
			     byte_length   <= 3;
			     write_data    <= {S_DAT_I[31:8],8'h00};
			  end
			  4'b1111:begin
			     
			     spi_cmd[1:0]  <= 2'b00;
			     byte_length   <= 4;
			     write_data    <= S_DAT_I;
			  end
			  default:begin
			     
			     spi_cmd[1:0]  <= 2'b00;
			     byte_length   <= 4;
			     write_data    <= S_DAT_I;
			  end
			endcase // case (S_SEL_I)
			
			cmd_bytes     <= 4;
			page_cmd      <= 1'b0;
			spi_req       <= 1'b1;
			wb_state      <= WB_PORTA;
		     end // if (S_STB_I && S_CYC_I && ~S_ACK_O)
		     else if (ctrl_port_req) begin
			
			S_ACK_O       <= 1'b0;
		       	
			cmd_bytes     <= ctrl_cmd_bytes;
			byte_length   <= ctrl_byte_length;
			page_cmd      <= ctrl_page_cmd;
			wr_enb        <= ctrl_wr_enb;
			write_data    <= ALIGN_ctrl_write_data;
			spi_cmd       <= ctrl_spi_cmd;
			spi_wr        <= ctrl_spi_wr;
			spi_req       <= 1'b1;
			wb_state      <= WB_PORTB;
		     end // if (ctrl_port_req)
		     else
		       S_ACK_O       <= 1'b0;
		  end // if (!spi_ack)
	       	  else
		    S_ACK_O       <= 1'b0;
		
		WB_PORTA:
		  if (spi_ack) begin
		     
		     spi_req  <= 1'b0;
		     if (~spi_wr) begin
			
			S_ACK_O       <= 1'b1;
			case (S_SEL_I[3:0])
			  4'b0001:S_DAT_O <= {24'h000000,read_data[7:0]};
			  4'b0010:S_DAT_O <= {16'h0000,read_data[7:0],8'h00};
			  4'b0100:S_DAT_O <= {8'h00,read_data[7:0],16'h0000};
			  4'b1000:S_DAT_O <= {read_data[7:0],24'h000000};
			  4'b0011:S_DAT_O <= {16'h0000,read_data[15:0]};
			  4'b0110:S_DAT_O <= {8'h00,read_data[15:0],8'h00};
			  4'b1100:S_DAT_O <= {read_data[15:0],16'h0000};
			  4'b0111:S_DAT_O <= {8'h00,read_data[23:0]};
			  4'b1110:S_DAT_O <= {read_data[23:0],8'h00};
			  4'b1111:S_DAT_O <= read_data;
			  default:S_DAT_O <= read_data;
			endcase
		     end 
		     else
		       S_ACK_O       <= 1'b0;
		     
		     wb_state      <= WB_IDLE;
		  end 
		  else
		    S_ACK_O       <= 1'b0;
		
		WB_PORTB:
		  if (spi_ack) begin
		     
		     spi_req  <= 1'b0;
		     wb_state <= WB_IDLE;
		  end
		
		default: begin
		   
		   spi_req  <= 1'b0;
		   wb_state <= WB_IDLE;
		end
	      endcase // case (wb_state)
	   end // else: !if(RST_I)
      end // else: !if(WB_DAT_WIDTH == 8)
   endgenerate
   
   /*----------------------------------------------------------------------
    
    SPI Flash Control Port
    
    ----------------------------------------------------------------------*/
   generate
      if (C_PORT_ENABLE) begin
	 
	 assign spi_read      = reg_spi_read;
	 assign spi_fast_read = reg_spi_fast_read;
	 assign spi_byte_prg  = reg_spi_byte_prg;
	 assign spi_page_prg  = reg_spi_page_prg;
	 assign spi_blk1_ers  = reg_spi_blk1_ers;
	 assign spi_blk2_ers  = reg_spi_blk2_ers;
	 assign spi_blk3_ers  = reg_spi_blk3_ers;
	 assign spi_chip_ers  = reg_spi_chip_ers;
	 assign spi_wrt_disb  = reg_spi_wrt_disb;
	 assign spi_wrt_enb   = reg_spi_wrt_enb;
	 assign spi_read_stat = reg_spi_read_stat;
	 assign spi_wrt_stat  = reg_spi_wrt_stat;
	 assign spi_pwd_down  = reg_spi_pwd_down;
	 assign spi_pwd_up    = reg_spi_pwd_up;
	 assign spi_dev_id    = reg_spi_dev_id;
	 
	 assign fast_read     = reg_fast_read;
      end
      else begin
	 
	 assign spi_read      = SPI_READ;
	 assign spi_fast_read = SPI_FAST_READ;
	 assign spi_byte_prg  = SPI_BYTE_PRG;
	 assign spi_page_prg  = SPI_PAGE_PRG;
	 assign spi_blk1_ers  = SPI_BLK1_ERS;
	 assign spi_blk2_ers  = SPI_BLK2_ERS;
	 assign spi_blk3_ers  = SPI_BLK3_ERS;
	 assign spi_chip_ers  = SPI_CHIP_ERS;
	 assign spi_wrt_disb  = SPI_WRT_DISB;
	 assign spi_wrt_enb   = SPI_WRT_ENB;
	 assign spi_read_stat = SPI_READ_STAT;
	 assign spi_wrt_stat  = SPI_WRT_STAT;
	 assign spi_pwd_down  = SPI_PWD_DOWN;
	 assign spi_pwd_up    = SPI_PWD_UP;
	 assign spi_dev_id    = SPI_DEV_ID;
	 
	 assign fast_read     = 1'b0;
      end
   endgenerate
   
   reg [C_WB_DAT_WIDTH-1:0] reg_C_DAT_O;
   reg 			    reg_C_ACK_O;
   assign C_ERR_O = 1'b0;
   assign C_RTY_O = 1'b0;
   generate
      if (C_PORT_ENABLE) begin
	 assign C_ACK_O = reg_C_ACK_O;
	 assign C_DAT_O = reg_C_DAT_O;
      end
      else begin
	 assign C_ACK_O = 0;
	 assign C_DAT_O = 0;
      end
   endgenerate
   
   reg [C_WB_DAT_WIDTH-1:0] reg_wb2spi_data;
   reg 			    reg_wb2spi_we;
   generate
      if (PAGE_PRG_BUF_ENA == 1) begin
	 if (C_WB_DAT_WIDTH == 8)
	   assign wb2spi_wr_addr = C_ADR_I[BUF_WIDTH-1:0];
	 else
	   assign wb2spi_wr_addr = C_ADR_I>>2;
	 
	 assign wb2spi_data = reg_wb2spi_data;
	 assign wb2spi_we = reg_wb2spi_we;
      end
      else begin
	 assign wb2spi_wr_addr = 0;
	 assign wb2spi_data = 0;
	 assign wb2spi_we = 0;
      end
      
      if (PAGE_READ_BUF_ENA == 1)
	if (C_WB_DAT_WIDTH == 8) 
	  assign spi2wb_rd_addr = C_ADR_I[BUF_WIDTH-1:0];
	else
	  assign spi2wb_rd_addr = C_ADR_I>>2;
      
      else
	assign spi2wb_rd_addr = 0;
   endgenerate
   
   reg [31:0] spi_cmd_arb;
   reg [3:0]  bytes_arb;
   reg [2:0]  length_arb;
   reg [15:0] page_prg_length, page_rd_length;
   reg 	      c_ctrl_port_req;
   generate
      if (C_PORT_ENABLE == 1) begin
	 if (C_WB_DAT_WIDTH == 8) begin
	    
	    always @(posedge CLK_I or posedge RST_I)
	      begin
		 if (RST_I) begin
		    c_ctrl_port_req     <= 1'b0;
		    ctr_state           <= CTR_IDLE;
		    reg_C_DAT_O         <= 32'h000000;
		    reg_C_ACK_O         <= 1'b0;
		    reg_wb2spi_data     <= 8'h00;
		    reg_wb2spi_we       <= 1'b0;
		    spi_cmd_arb         <= 32'h00000000;
		    spi_cmd_ext         <= 32'h00000000;
		    bytes_arb           <= 4'h0;
		    length_arb          <= 3'b000;
		    read_data_arb       <= 8'h00;
		    reg_fast_read       <= 1'b0;
		    page_prg_length     <= 0;
		    page_rd_length      <= 0;
		    reg_spi_read        <= SPI_READ;        //8'h03;
		    reg_spi_fast_read   <= SPI_FAST_READ;   //8'h0b;
		    reg_spi_byte_prg    <= SPI_BYTE_PRG;    //8'h02;
		    reg_spi_page_prg    <= SPI_PAGE_PRG;    //8'h02;
		    reg_spi_blk1_ers    <= SPI_BLK1_ERS;    //8'h20;
		    reg_spi_blk2_ers    <= SPI_BLK2_ERS;    //8'h52;
		    reg_spi_blk3_ers    <= SPI_BLK3_ERS;    //8'hD8;
		    reg_spi_chip_ers    <= SPI_CHIP_ERS;    //8'h60;
		    reg_spi_wrt_enb     <= SPI_WRT_ENB;     //8'h06;
		    reg_spi_wrt_disb    <= SPI_WRT_DISB;    //8'h04;
		    reg_spi_read_stat   <= SPI_READ_STAT;   //8'h05;
		    reg_spi_wrt_stat    <= SPI_WRT_STAT;    //8'h10;
		    reg_spi_pwd_down    <= SPI_PWD_DOWN;    //8'hB9;
		    reg_spi_pwd_up      <= SPI_PWD_UP;      //8'hAB;
		    reg_spi_dev_id      <= SPI_DEV_ID;	 //8'h9F;
		 end 
		 else 
		   case (ctr_state)
		     CTR_IDLE:
		       if (C_STB_I && C_CYC_I && ~reg_C_ACK_O) begin
			  if ((C_ADR_I[10:0] == 11'h054 && C_DAT_I[0] == 1'b1) // h054 arbitrary command
			      || (C_ADR_I[10:6] == 5'b00000 && C_ADR_I[1:0] == 2'b00)) begin // h000~h03f spi command
			     if (wb_state == WB_IDLE) begin
				c_ctrl_port_req <= 1'b1;
				ctr_state       <= CTR_CMD;
				reg_C_ACK_O     <= 1'b0;
			     end
			  end
			  else if (C_ADR_I[10:6] == 5'b00000) begin
			     reg_C_ACK_O <= 1'b1;
			     reg_C_DAT_O <= 8'b00;
			     
			     if (C_WE_I)
			       case (C_ADR_I[1:0])
				 2'b01: spi_cmd_arb[23:16] <= C_DAT_I;
				 2'b10: spi_cmd_arb[15: 8] <= C_DAT_I;
				 2'b11: spi_cmd_arb[ 7: 0] <= C_DAT_I;
				 default:
				   spi_cmd_arb[31:24] <= C_DAT_I;
			       endcase
			  end
			  else if (C_ADR_I[10:6] == 5'b00001) begin
			     reg_C_ACK_O <= 1'b1;
			     
			     case (C_ADR_I[4:0])
			       //040h-043h RW	Arbitrary command to SPI flash. B_DAT_I defined given command,
			       // if the command is larger than 4 bytes, the higher bytes put on address 044h.
			       5'h00:
				 if (C_WE_I)
				   spi_cmd_arb[31:24] <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= spi_cmd_arb[31:24];
			       5'h01:
				 if (C_WE_I)
				   spi_cmd_arb[23:16] <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= spi_cmd_arb[23:16];
			       5'h02:
				 if (C_WE_I)
				   spi_cmd_arb[15: 8] <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= spi_cmd_arb[15: 8];
			       5'h03:
				 if (C_WE_I)
				   spi_cmd_arb[ 7: 0] <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= spi_cmd_arb[ 7: 0];
			       //044h-047h RW	Arbitrary command, higher 4 bytes
			       5'h04:
				 if (C_WE_I)
				   spi_cmd_ext[31:24] <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= spi_cmd_ext[31:24];
			       5'h05:
				 if (C_WE_I)
				   spi_cmd_ext[23:16] <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= spi_cmd_ext[23:16];
			       5'h06:
				 if (C_WE_I)
				   spi_cmd_ext[15: 8] <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= spi_cmd_ext[15: 8];
			       5'h07:
				 if (C_WE_I)
				   spi_cmd_ext[ 7: 0] <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_cmd_ext[ 7: 0];
			       //048h	RW	B_DAT_I[7:0] is length of command
			       5'h08:
				 if (C_WE_I)
				   bytes_arb          <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= bytes_arb;
			       //04ch	RW	Length of return data. If B_DAT_I is 0, it means that the command is no return data.
			       5'h0c:
				 if (C_WE_I)
				   length_arb         <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= length_arb;
			       //050h-053h	Read	Return data from SPI flash
			       5'h10:
				 reg_C_DAT_O          <= read_data_arb;
			       5'h11:
				 reg_C_DAT_O          <= read_data_arb;
			       5'h12:
				 reg_C_DAT_O          <= read_data_arb;
			       5'h13:
				 reg_C_DAT_O          <= read_data_arb;
			     endcase
			  end
			  else if (C_ADR_I[10:8] == 3'b001) begin // h100~h1fc config command
			     reg_C_ACK_O <= 1'b1;
			     
			     case ({1'b1,C_ADR_I[7:0]})
			       // 100h	RW	Fast read or low frequency read command, ¡°1¡¯ of B_DAT_I bit 0 define fast read,
			       //¡°0¡± of B_DAT_I bit 0 define low frequency read command
			       9'h100:
				 if (C_WE_I)
				   reg_fast_read      <= C_DAT_I[0];
				 else
				   reg_C_DAT_O        <= fast_read;
			       // 104h	RW	Page program length, B_DAT_I[15:0] defined the page program length. Default value is page size.
			       9'h104:
				 if (C_WE_I)
				   page_prg_length[15:8] <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= page_prg_length[15:8];
			       9'h105:
				 if (C_WE_I)
				   page_prg_length[7:0] <= C_DAT_I;
				 else
				   reg_C_DAT_O        <= page_prg_length[7:0];
			       // 108h	RW	Page read command length, B_DAT_I[15:0] defined the page read length.. Default value is page size.
			       9'h108:
				 if (C_WE_I)
				   page_rd_length[15:8] <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= page_rd_length[15:8];
			       9'h109:
				 if (C_WE_I)
				   page_rd_length[7:0]<= C_DAT_I;
				 else
				   reg_C_DAT_O         <= page_rd_length[7:0];
			       // 180h	RW	Config Slow read command
			       9'h180:
				 if (C_WE_I)
				   reg_spi_read        <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_read;
			       // 184h	RW	Config Fast read command
			       9'h184:
				 if (C_WE_I)
				   reg_spi_fast_read   <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_fast_read;
			       // 188h	RW	Config Byte program command
			       9'h188:
				 if (C_WE_I)
				   reg_spi_byte_prg    <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_byte_prg;
			       // 18ch	RW	Config Page program command
			       9'h18c:
				 if (C_WE_I)
				   reg_spi_page_prg    <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_page_prg;
			       // 190h	RW	Config Type1 block erase command, 4K erase
			       9'h190:
				 if (C_WE_I)
				   reg_spi_blk1_ers    <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_blk1_ers;
			       // 194h	RW	Config Type2 block erase command, 32k erase
			       9'h194:
				 if (C_WE_I)
				   reg_spi_blk2_ers    <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_blk2_ers;
			       // 198h	RW	Config Type3 block erase command, 64k erase
			       9'h198:
				 if (C_WE_I)
				   reg_spi_blk3_ers    <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_blk3_ers;
			       // 19ch	RW	Config Chip erase command
			       9'h19c:
				 if (C_WE_I)
				   reg_spi_chip_ers    <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_chip_ers;
			       // 1a0h	RW	Config Write enable command
			       9'h1a0:
				 if (C_WE_I)
				   reg_spi_wrt_enb     <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_wrt_enb;
			       // 1a4h	RW	Config Write disable command
			       9'h1a4:
				 if (C_WE_I)
				   reg_spi_wrt_disb    <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_wrt_disb;
			       // 1a8h	RW	Config Read status register command
			       9'h1a8:
				 if (C_WE_I)
				   reg_spi_read_stat   <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_read_stat;
			       // 1ach	RW	Config Write status register command
			       9'h1ac:
				 if (C_WE_I)
				   reg_spi_wrt_stat    <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_wrt_stat;
			       // 1b0h	RW	Config Deep power down command
			       9'h1b0:
				 if (C_WE_I)
				   reg_spi_pwd_down    <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_pwd_down;
			       // 1b4h	RW	Config Resume from deep power down command
			       9'h1b4:
				 if (C_WE_I)
				   reg_spi_pwd_up      <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_pwd_up;
			       // 1b8h	RW	Config Read manufacturer and device ID command
			       9'h1b8:
				 if (C_WE_I)
				   reg_spi_dev_id      <= C_DAT_I;
				 else
				   reg_C_DAT_O         <= spi_dev_id;
			     endcase // case ({1'b1,C_ADR_I[7:2],2'b00})
			  end // if (C_ADR_I[10:8] == 3'b001)
			  else if (C_ADR_I[10:9] == 2'b01)  begin // h200~h3fc page programe buffer space
			     reg_wb2spi_data <= C_DAT_I;
			     reg_wb2spi_we   <= 1'b1;
			     reg_C_ACK_O     <= 1'b1;
			  end
			  else if (C_ADR_I[10:9] == 2'b10)  begin // h400~h4fc page read buffer space
			     reg_C_DAT_O     <= spi2wb_q;
			     reg_C_ACK_O     <= 1'b1;
			  end
		       end 
		       else begin
			  reg_C_ACK_O     <= 1'b0;
			  c_ctrl_port_req <= 1'b0;
			  ctr_state       <= CTR_IDLE;
			  reg_wb2spi_we   <= 1'b0;
		       end
		     
		     CTR_CMD :
		       if (wb_state == WB_PORTB) begin
			  c_ctrl_port_req  <= 1'b0;
			  if (spi_wr) begin // write control command
			     reg_C_ACK_O   <= 1'b1;
			     ctr_state     <= CTR_IDLE;
			  end 
			  else if (spi_ack) begin // read control command and finish transferer
			     if (C_ADR_I[10:0] == 11'h054) // arbitrary read command
			       read_data_arb <= read_data;
			     
			     reg_C_ACK_O   <= 1'b1;
			     reg_C_DAT_O   <= read_data;
			     ctr_state     <= CTR_IDLE;
			  end 
			  else
			    reg_C_ACK_O    <= 1'b0;
		       end
		   endcase // case (ctr_state)
	      end // always @ (posedge CLK_I or posedge RST_I)
	    
	    assign ctrl_port_req = c_ctrl_port_req;
	    assign ctrl_port_cmd = spi_cmd_arb[23:0];
	    assign ctrl_port_dat = C_DAT_I[7:0];
	    
	 end // if (C_WB_DAT_WIDTH == 8)
	 else begin
	    
	    always @(posedge CLK_I or posedge RST_I)
	      begin
		 if (RST_I) begin
		    c_ctrl_port_req     <= 1'b0;
		    ctr_state           <= CTR_IDLE;
		    reg_C_DAT_O         <= 32'h000000;
		    reg_C_ACK_O         <= 1'b0;
		    reg_wb2spi_data     <= 32'h000000;
		    reg_wb2spi_we       <= 1'b0;
		    spi_cmd_arb         <= 32'h00000000;
		    spi_cmd_ext         <= 32'h00000000;
		    bytes_arb           <= 4'h0;
		    length_arb          <= 3'b000;
		    read_data_arb       <= 32'h00000000;
		    reg_fast_read       <= 1'b0;
		    page_prg_length     <= 0;
		    page_rd_length      <= 0;
		    reg_spi_read        <= SPI_READ;        //8'h03;
		    reg_spi_fast_read   <= SPI_FAST_READ;   //8'h0b;
		    reg_spi_byte_prg    <= SPI_BYTE_PRG;    //8'h02;
		    reg_spi_page_prg    <= SPI_PAGE_PRG;    //8'h02;
		    reg_spi_blk1_ers    <= SPI_BLK1_ERS;    //8'h20;
		    reg_spi_blk2_ers    <= SPI_BLK2_ERS;    //8'h52;
		    reg_spi_blk3_ers    <= SPI_BLK3_ERS;    //8'hD8;
		    reg_spi_chip_ers    <= SPI_CHIP_ERS;    //8'h60;
		    reg_spi_wrt_enb     <= SPI_WRT_ENB;     //8'h06;
		    reg_spi_wrt_disb    <= SPI_WRT_DISB;    //8'h04;
		    reg_spi_read_stat   <= SPI_READ_STAT;   //8'h05;
		    reg_spi_wrt_stat    <= SPI_WRT_STAT;    //8'h10;
		    reg_spi_pwd_down    <= SPI_PWD_DOWN;    //8'hB9;
		    reg_spi_pwd_up      <= SPI_PWD_UP;      //8'hAB;
		    reg_spi_dev_id      <= SPI_DEV_ID;	    //8'h9F;
		 end
		 else
		   case (ctr_state)
		     CTR_IDLE:
		       if (C_STB_I && C_CYC_I && ~reg_C_ACK_O) begin
			  if ((C_ADR_I[10:0] == 11'h054 && C_DAT_I[0] == 1'b1) // h054 arbitrary command
			      || C_ADR_I[10:6] == 5'b00000) begin // h000~h03f spi command
			     if (wb_state == WB_IDLE) begin
				c_ctrl_port_req <= 1'b1;
				ctr_state       <= CTR_CMD;
				reg_C_ACK_O     <= 1'b0;
			     end
			  end 
			  else if (C_ADR_I[10:5] == 6'b000010) begin           // h040~h05c arbitrary command config space
			     reg_C_ACK_O <= 1'b1;
			     
			     case ({4'b0010,C_ADR_I[4:2],2'b00})
			       //040h	RW	Arbitrary command to SPI flash. B_DAT_I defined given command,
			       // if the command is larger than 4 bytes, the higher bytes put on address 044h.
			       9'h040:
				 if (C_WE_I)
				   spi_cmd_arb <= C_DAT_I;
				 else
				   reg_C_DAT_O <= spi_cmd_arb;
			       //044h	RW	Arbitrary command, higher 4 bytes
			       9'h044:
				 if (C_WE_I)
				   spi_cmd_ext <= C_DAT_I;
				 else
				   reg_C_DAT_O <= spi_cmd_ext;
			       //048h	RW	B_DAT_I[7:0] is length of command
			       9'h048:
				 if (C_WE_I)
				   bytes_arb   <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O <= bytes_arb;
			       //04ch	RW	Length of return data. If B_DAT_I is 0, it means that the command is no return data.
			       9'h04c:
				 if (C_WE_I)
				   length_arb  <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O <= length_arb;
			       //050h	Read	Return data from SPI flash
			       9'h050:
				 reg_C_DAT_O   <= read_data_arb;
			     endcase
			  end 
			  else if (C_ADR_I[10:8] == 3'b001) begin              // h100~h1fc config command
			     reg_C_ACK_O <= 1'b1;
			     
			     case ({1'b1,C_ADR_I[7:2],2'b00})
			       // 100h	RW	Fast read or low frequency read command, ¡°1¡¯ of B_DAT_I bit 0 define fast read,
			       //¡°0¡± of B_DAT_I bit 0 define low frequency read command
			       9'h100:
				 if (C_WE_I)
				   reg_fast_read      <= C_DAT_I[24];
				 else
				   reg_C_DAT_O        <= {32{fast_read}};
			       // 104h	RW	Page program length, B_DAT_I[15:0] defined the page program length. Default value is page size.
			       9'h104:
				 if (C_WE_I)
				   page_prg_length    <= C_DAT_I[31:16];
				 else
				   reg_C_DAT_O        <= {2{page_prg_length}};
			       // 108h	RW	Page read command length, B_DAT_I[15:0] defined the page read length.. Default value is page size.
			       9'h108:
				 if (C_WE_I)
				   page_rd_length     <= C_DAT_I[31:16];
				 else
				   reg_C_DAT_O        <= {2{page_rd_length}};
			       // 180h	RW	Config Slow read command
			       9'h180:
				 if (C_WE_I)
				   reg_spi_read       <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O        <= {4{spi_read}};
			       // 184h	RW	Config Fast read command
			       9'h184:
				 if (C_WE_I)
				   reg_spi_fast_read  <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O        <= {4{spi_fast_read}};
			       // 188h	RW	Config Byte program command
			       9'h188:
				 if (C_WE_I)
				   reg_spi_byte_prg   <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O        <= {4{spi_byte_prg}};
			       // 18ch	RW	Config Page program command
			       9'h18c:
				 if (C_WE_I)
				   reg_spi_page_prg  <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_page_prg}};
			       // 190h	RW	Config Type1 block erase command, 4K erase
			       9'h190:
				 if (C_WE_I)
				   reg_spi_blk1_ers  <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_blk1_ers}};
			       // 194h	RW	Config Type2 block erase command, 32k erase
			       9'h194:
				 if (C_WE_I)
				   reg_spi_blk2_ers  <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_blk2_ers}};
			       // 198h	RW	Config Type3 block erase command, 64k erase
			       9'h198:
				 if (C_WE_I)
				   reg_spi_blk3_ers  <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_blk3_ers}};
			       // 19ch	RW	Config Chip erase command
			       9'h19c:
				 if (C_WE_I)
				   reg_spi_chip_ers  <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_chip_ers}};
			       // 1a0h	RW	Config Write enable command
			       9'h1a0:
				 if (C_WE_I)
				   reg_spi_wrt_enb   <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_wrt_enb}};
			       // 1a4h	RW	Config Write disable command
			       9'h1a4:
				 if (C_WE_I)
				   reg_spi_wrt_disb  <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_wrt_disb}};
			       // 1a8h	RW	Config Read status register command
			       9'h1a8:
				 if (C_WE_I)
				   reg_spi_read_stat <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_read_stat}};
			       // 1ach	RW	Config Write status register command
			       9'h1ac:
				 if (C_WE_I)
				   reg_spi_wrt_stat  <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_wrt_stat}};
			       // 1b0h	RW	Config Deep power down command
			       9'h1b0:
				 if (C_WE_I)
				   reg_spi_pwd_down  <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_pwd_down}};
			       // 1b4h	RW	Config Resume from deep power down command
			       9'h1b4:
				 if (C_WE_I)
				   reg_spi_pwd_up    <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_pwd_up}};
			       // 1b8h	RW	Config Read manufacturer and device ID command
			       9'h1b8:
				 if (C_WE_I)
				   reg_spi_dev_id    <= C_DAT_I[31:24];
				 else
				   reg_C_DAT_O       <= {4{spi_dev_id}};
			     endcase // case ({1'b1,C_ADR_I[7:2],2'b00})
			  end // if (C_ADR_I[10:8] == 3'b001)
			  else if (C_ADR_I[10:9] == 2'b01)  begin              // h200~h3fc page programe buffer space
			     reg_wb2spi_data <= C_DAT_I;
			     reg_wb2spi_we   <= 1'b1;
			     reg_C_ACK_O     <= 1'b1;
			  end
			  else if (C_ADR_I[10:9] == 2'b10)  begin              // h400~h4fc page read buffer space
			     reg_C_DAT_O <= spi2wb_q;
			     reg_C_ACK_O <= 1'b1;
			  end
		       end // if (C_STB_I && C_CYC_I && ~reg_C_ACK_O)
		       else begin
			  reg_C_ACK_O     <= 1'b0;
			  c_ctrl_port_req <= 1'b0;
			  ctr_state       <= CTR_IDLE;
			  reg_wb2spi_we   <= 1'b0;
		       end
		     
		     CTR_CMD :
		       if (wb_state == WB_PORTB) begin
			  c_ctrl_port_req <= 1'b0;
			  if (spi_wr) begin                  // write control command
			     reg_C_ACK_O  <= 1'b1;
			     ctr_state    <= CTR_IDLE;
			  end 
			  else if (spi_ack) begin            // read control command and finish transferer
			     if (C_ADR_I[10:0] == 11'h054)   // arbitrary read command
			       read_data_arb <= read_data;
			     
			     reg_C_ACK_O  <= 1'b1;
			     if (C_ADR_I[10:0] == 11'h054)
			       reg_C_DAT_O  <= read_data;
		             else if (C_ADR_I[10:0] == 11'h030)
						reg_C_DAT_O  <= {4{read_data[31:24]}};
					 else
			       reg_C_DAT_O  <= {4{read_data[7:0]}};
			     ctr_state    <= CTR_IDLE;
			  end 
			  else
			    reg_C_ACK_O   <= 1'b0;
		       end
		   endcase // case (ctr_state)
	      end // always @ (posedge CLK_I or posedge RST_I)
	    	    
	    assign ctrl_port_req = c_ctrl_port_req;
	    assign ctrl_port_cmd = C_DAT_I[23:0];
	    assign ctrl_port_dat = C_DAT_I[31:24];
	    
	 end // else: !if(C_WB_DAT_WIDTH == 8)
	 
	 always @(/*AUTOSENSE*/C_ADR_I or C_DAT_I or bytes_arb
		  or ctrl_port_cmd or ctrl_port_dat or length_arb
		  or page_prg_length or page_rd_length or spi_blk1_ers
		  or spi_blk2_ers or spi_blk3_ers or spi_byte_prg
		  or spi_chip_ers or spi_cmd_arb or spi_dev_id
		  or spi_pwd_down or spi_pwd_up or spi_read
		  or spi_read_stat or spi_wrt_disb or spi_wrt_enb
		  or spi_wrt_stat)
	   begin
	      case (C_ADR_I[6:0])
		// 000h Write Page program command. spi_cmd_arb[23:0] defined page program command address.
		7'h00: begin
		   ctrl_spi_cmd       = {spi_byte_prg,ctrl_port_cmd};
		   ctrl_cmd_bytes     = 4;
		   ctrl_byte_length   = page_prg_length;
		   ctrl_page_cmd      = 1'b1;
		   ctrl_wr_enb        = 1'b1;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b1;
		end
		
		// 004h Write Page read command. spi_cmd_arb[23:0] defined page read command address.
		7'h04: begin
		   if (reg_fast_read == 1'b1)
			   ctrl_spi_cmd       = {spi_fast_read,ctrl_port_cmd};
		   else
			   ctrl_spi_cmd       = {spi_read,ctrl_port_cmd};
		   ctrl_cmd_bytes     = 4;
		   ctrl_byte_length   = page_rd_length;
		   ctrl_page_cmd      = 1'b1;
		   ctrl_wr_enb        = 1'b0;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b0;
		end
		
		// 008h Write Type1 block erase, 4K erase. spi_cmd_arb[23:0] defined erase address
		7'h08: begin
		   ctrl_spi_cmd       = {spi_blk1_ers,ctrl_port_cmd};
		   ctrl_cmd_bytes     = 4;
		   ctrl_byte_length   = 0;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b1;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b1;
		end
		
		// 00ch Write Type2 block erase, 32k erase. spi_cmd_arb[23:0] defined erase address
		7'h0c: begin
		   ctrl_spi_cmd       = {spi_blk2_ers,ctrl_port_cmd};
		   ctrl_cmd_bytes     = 4;
		   ctrl_byte_length   = 0;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b1;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b1;
		end
		
		// 010h Write Type3 block erase, 64k erase. spi_cmd_arb[23:0] defined erase address
		7'h10: begin
		   ctrl_spi_cmd       = {spi_blk3_ers,ctrl_port_cmd};
		   ctrl_cmd_bytes     = 4;
		   ctrl_byte_length   = 0;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b1;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b1;
		end
		
		// 014h Write Chip erase command. spi_cmd_arb is ignored.
		7'h14: begin
		   ctrl_spi_cmd       = {spi_chip_ers,24'h000000};
		   ctrl_cmd_bytes     = 1;
		   ctrl_byte_length   = 0;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b1;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b1;
		end
		
		// 018h Write Write enable command. spi_cmd_arb is ignored
		7'h18: begin
		   ctrl_spi_cmd       = {spi_wrt_enb,24'h000000};
		   ctrl_cmd_bytes     = 1;
		   ctrl_byte_length   = 0;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b0;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b1;
		end
		
		// 01ch Write Write disable command. spi_cmd_arb is ignored.
		7'h1c: begin
		   ctrl_spi_cmd       = {spi_wrt_disb,24'h000000};
		   ctrl_cmd_bytes     = 1;
		   ctrl_byte_length   = 0;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b0;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b1;
		end
		
		// 020h Read Read status register. C_DAT_O[7:0] is status register data.
		7'h20: begin
		   ctrl_spi_cmd       = {spi_read_stat,24'h000000};
		   ctrl_cmd_bytes     = 1;
		   ctrl_byte_length   = 1;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b0;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b0;
		end
		
		// 024h Write Write status register. C_DAT_I[7:0] is data write to status register.
		7'h24: begin
		   ctrl_spi_cmd       = {spi_wrt_stat,24'h000000};
		   ctrl_cmd_bytes     = 1;
		   ctrl_byte_length   = 1;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b1;
		   ctrl_write_data    = ctrl_port_dat;
		   ctrl_spi_wr        = 1'b1;
		end
		
		// 028h Write Deep power down. spi_cmd_arb is ignored.
		7'h28: begin
		   ctrl_spi_cmd       = {spi_pwd_down,24'h000000};
		   ctrl_cmd_bytes     = 1;
		   ctrl_byte_length   = 0;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b0;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b1;
		end
		
		// 02ch Write Resume from deep power down. spi_cmd_arb is ignored
		7'h2c: begin
		   ctrl_spi_cmd       = {spi_pwd_up,24'h000000};
		   ctrl_cmd_bytes     = 1;
		   ctrl_byte_length   = 0;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b0;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b1;
		end
		
		// 030h Read Read manufacturer and device ID. C_DAT_O[31:0] is ID data.
		7'h30: begin
		   ctrl_spi_cmd       = {spi_dev_id,24'h000000};
		   ctrl_cmd_bytes     = 1;
		   if ( WB_DAT_WIDTH == 8) begin
				ctrl_byte_length   = 1;
		   end
		   else begin
				ctrl_byte_length   = 4;
		   end
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b0;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b0;
		end
		
		// issue an arbitrary command
		7'h54: begin
		   ctrl_spi_cmd       = spi_cmd_arb;
		   ctrl_cmd_bytes     = bytes_arb;
		   ctrl_byte_length   = length_arb;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = C_DAT_I[1];
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = length_arb == 0 ? 1'b1 : 1'b0;
		end
		
		// select read status register as default command
		default: begin
		   ctrl_spi_cmd       = {spi_read_stat,24'h000000};
		   ctrl_cmd_bytes     = 1;
		   ctrl_byte_length   = 1;
		   ctrl_page_cmd      = 1'b0;
		   ctrl_wr_enb        = 1'b0;
		   ctrl_write_data    = 8'h00;
		   ctrl_spi_wr        = 1'b0;
		end
	      endcase // case ({C_ADR_I[6:2],2'b00})
	   end
	 
      end // if (C_PORT_ENABLE == 1)
      else begin
	 
	 assign ctrl_port_req = 0;
	 assign ctrl_port_cmd = 0;
	 assign ctrl_port_dat = 0;
	 
	 always @(*)
	   begin
	      ctrl_spi_cmd       = 0;
	      ctrl_cmd_bytes     = 0;
	      ctrl_byte_length   = 0;
	      ctrl_page_cmd      = 0;
	      ctrl_wr_enb        = 0;
	      ctrl_write_data    = 0;
	      ctrl_spi_wr        = 0;
	   end
	 
      end // else: !if(C_PORT_ENABLE == 1)
   endgenerate
   
   generate
      if (WB_DAT_WIDTH == 8)
	assign ALIGN_ctrl_write_data = ctrl_write_data;
      else
	assign ALIGN_ctrl_write_data = {ctrl_write_data, 24'b0};
   endgenerate
   
endmodule
